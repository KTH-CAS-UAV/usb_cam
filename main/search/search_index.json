{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"usb_cam","text":""},{"location":"#a-ros-2-driver-for-v4l-usb-cameras","title":"A ROS 2 Driver for V4L USB Cameras","text":"<p>This package is based off of V4L devices specifically instead of just UVC.</p> <p>For ros1 documentation, see the ROS wiki.</p>"},{"location":"#supported-ros-2-distros-and-platforms","title":"Supported ROS 2 Distros and Platforms","text":"<p>All Officially supported Linux Distros and corresponding ROS 2 releases are supported. Please create an issue if you experience any problems on these platforms.</p> <p>Windows: TBD/Untested/Unproven MacOS: TBD/Untested/Unproven</p> <p>For either MacOS or Windows - if you would like to try and get it working please create an issue to document your effort. If it works we can add it to the instructions here!</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Assuming you have a supported ROS 2 distro installed, run the following command to install the binary release:</p> <pre><code>sudo apt-get install ros-&lt;ros2-distro&gt;-usb-cam\n</code></pre> <p>As of today this package should be available for binary installation on all active ROS 2 distros.</p> <p>If for some reason you cannot install the binaries, follow the directions below to compile from source.</p>"},{"location":"#building-from-source","title":"Building from Source","text":"<p>Clone/Download the source code into your workspace:</p> <pre><code>cd /path/to/colcon_ws/src\ngit clone https://github.com/ros-drivers/usb_cam.git\n</code></pre> <p>Or click on the green \"Download zip\" button on the repo's github webpage.</p> <p>Once downloaded and ensuring you have sourced your ROS 2 underlay, go ahead and install the dependencies:</p> <pre><code>cd /path/to/colcon_ws\nrosdep install --from-paths src --ignore-src -y\n</code></pre> <p>From there you should have all the necessary dependencies installed to compile the <code>usb_cam</code> package:</p> <pre><code>cd /path/to/colcon_ws\ncolcon build\nsource /path/to/colcon_ws/install/setup.bash\n</code></pre> <p>Be sure to source the newly built packages after a successful build.</p> <p>Once sourced, you should be able to run the package in one of three ways, shown in the next section.</p>"},{"location":"#running","title":"Running","text":"<p>The <code>usb_cam_node</code> can be ran with default settings, by setting specific parameters either via the command line or by loading in a parameters file.</p> <p>We provide a \"default\" params file in the <code>usb_cam/config/params.yaml</code> directory to get you started. Feel free to modify this file as you wish.</p> <p>Also provided is a launch file that should launch the <code>usb_cam_node_exe</code> executable along with an additional node that displays an image topic.</p> <p>The commands to run each of these different ways of starting the node are shown below:</p> <p>NOTE: you only need to run ONE of the commands below to run the node</p> <pre><code># run the executable with default settings (without params file)\nros2 run usb_cam usb_cam_node_exe\n\n# run the executable while passing in parameters via a yaml file\nros2 run usb_cam usb_cam_node_exe --ros-args --params-file /path/to/colcon_ws/src/usb_cam/config/params.yaml\n\n# launch the usb_cam executable that loads parameters from the same `usb_cam/config/params.yaml` file as above\n# along with an additional image viewer node\nros2 launch usb_cam camera.launch.py\n</code></pre>"},{"location":"#launching-multiple-usb_cams","title":"Launching Multiple usb_cam's","text":"<p>To launch multiple nodes at once, simply remap the namespace of each one:</p> <pre><code>ros2 run usb_cam usb_cam_node_exe --remap __ns:=/usb_cam_0 --params-file /path/to/usb_cam/config/params_0.yaml\nros2 run usb_cam usb_cam_node_exe --remap __ns:=/usb_cam_1 --params-file /path/to/usb_cam/config/params_1.yaml\n</code></pre>"},{"location":"#supported-formats","title":"Supported formats","text":""},{"location":"#device-supported-formats","title":"Device supported formats","text":"<p>To see a connected devices supported formats, run the <code>usb_cam_node</code> and observe the console output.</p> <p>An example output is:</p> <pre><code>This devices supproted formats:\n       Motion-JPEG: 1280 x 720 (30 Hz)\n       Motion-JPEG: 960 x 540 (30 Hz)\n       Motion-JPEG: 848 x 480 (30 Hz)\n       Motion-JPEG: 640 x 480 (30 Hz)\n       Motion-JPEG: 640 x 360 (30 Hz)\n       YUYV 4:2:2: 640 x 480 (30 Hz)\n       YUYV 4:2:2: 1280 x 720 (10 Hz)\n       YUYV 4:2:2: 640 x 360 (30 Hz)\n       YUYV 4:2:2: 424 x 240 (30 Hz)\n       YUYV 4:2:2: 320 x 240 (30 Hz)\n       YUYV 4:2:2: 320 x 180 (30 Hz)\n       YUYV 4:2:2: 160 x 120 (30 Hz)\n</code></pre>"},{"location":"#driver-supported-formats","title":"Driver supported formats","text":"<p>The driver has its own supported formats. See the source code for details.</p> <p>After observing the devices supported formats, specify which format to use via the parameters file with the <code>pixel_format</code> parameter.</p> <p>To see a list of all currently supported driver formats, run the following command:</p> <pre><code>ros2 run usb_cam usb_cam_node_exe --ros-args -p pixel_format:=\"test\"\n</code></pre> <p>Note: \"test\" here could be replaced with any non-supported pixel format string. The driver will detect if the given pixel format is supported or not.</p> <p>More formats and conversions can be added, contributions welcome!</p>"},{"location":"#supported-io-methods","title":"Supported IO methods","text":"<p>This driver supports three different IO methods as of today:</p> <ol> <li><code>read</code>: copies the video frame between user and kernal space</li> <li><code>mmap</code>: memory mapped buffers allocated in kernel space</li> <li><code>userptr</code>: memory buffers allocated in the user space</li> </ol> <p>To read more on the different methods, check out this article that provides a good overview of each</p>"},{"location":"#compression","title":"Compression","text":"<p>Big thanks to the <code>ros2_v4l2_camera</code> package and their documentation on this topic.</p> <p>The <code>usb_cam</code> should support compression by default since it uses <code>image_transport</code> to publish its images as long as the <code>image_transport_plugins</code> package is installed on your system. With the plugins installed the <code>usb_cam</code> package should publish a <code>compressed</code> topic automatically.</p> <p>Unfortunately <code>rviz2</code> and <code>show_image.py</code> do not support visualizing the compressed images just yet so you will need to republish the compressed image downstream to uncompress it:</p> <pre><code>ros2 run image_transport republish compressed raw --ros-args --remap in/compressed:=image_raw/compressed --remap out:=image_raw/uncompressed\n</code></pre>"},{"location":"#address-and-leak-sanitizing","title":"Address and leak sanitizing","text":"<p>Incorporated into the <code>CMakelists.txt</code> file to assist with memory leak and address sanitizing is a flag to add these compile commands to the targets.</p> <p>To enable them, pass in the <code>SANITIZE=1</code> flag:</p> <pre><code>colcon build --packages-select usb_cam --cmake-args -DSANITIZE=1\n</code></pre> <p>Once built, run the nodes executable directly and pass any <code>ASAN_OPTIONS</code> that are needed:</p> <pre><code>ASAN_OPTIONS=new_delete_type_mismatch=0 ./install/usb_cam/lib/usb_cam/usb_cam_node_exe \n</code></pre> <p>After shutting down the executable with <code>Ctrl+C</code>, the sanitizer will report any memory leaks.</p> <p>By default this is turned off since compiling with the sanatizer turned on causes bloat and slows down performance.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Doxygen files can be found on the ROS wiki.</p>"},{"location":"#license","title":"License","text":"<p>usb_cam is released with a BSD license. For full terms and conditions, see the LICENSE file.</p>"},{"location":"#authors","title":"Authors","text":"<p>See the AUTHORS file for a full list of contributors.</p>"},{"location":"api-reference/Classes/","title":"Classes","text":"<ul> <li>namespace rclcpp </li> <li>namespace usb_cam <ul> <li>class UsbCam </li> <li>class UsbCamNode </li> <li>struct capture_format_t </li> <li>namespace constants </li> <li>namespace conversions </li> <li>namespace formats <ul> <li>class M4202RGB </li> <li>class MJPEG2RGB </li> <li>class MONO16 </li> <li>class MONO8 </li> <li>class RAW_MJPEG </li> <li>class RGB8 </li> <li>class UYVY </li> <li>class UYVY2RGB </li> <li>class Y102MONO8 Also known as MONO10 to MONO8. </li> <li>class YUYV </li> <li>class YUYV2RGB </li> <li>class default_pixel_format </li> <li>struct format_arguments_t Helper structure to standardize all pixel_format_base constructors, so that they all have the same argument type. </li> <li>class pixel_format_base Base pixel format class. Provide all necessary information for converting between V4L2 and ROS formats. Meant to be overridden if conversion function is required. </li> </ul> </li> <li>struct image_t </li> <li>struct parameters_t </li> <li>namespace utils <ul> <li>struct buffer </li> </ul> </li> </ul> </li> </ul> <p>Updated on 2024-01-20 at 18:16:12 +0000</p>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/","title":"usb_cam::UsbCam","text":""},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#public-functions","title":"Public Functions","text":"Name ~UsbCam() std::vector&lt; capture_format_t &gt; supported_formats() void stop_capturing() void start_capturing() void start()Start the configured device. void shutdown(void )shutdown camera bool set_v4l_parameter(const std::string &amp; param, int value) bool set_v4l_parameter(const std::string &amp; param, const std::string &amp; value) bool set_pixel_format(const formats::format_arguments_t &amp; args)Check if the given format is supported by this device If it is supported, set the m_pixel_format variable to it. std::shared_ptr&lt; pixel_format_base &gt; set_pixel_format(const parameters_t &amp; parameters)Set pixel format from parameter list. Required to have logic within UsbCam object in case pixel format class requires additional information for conversion function (e.g. number of pixels, width, height, etc.) bool set_auto_focus(int value) unsigned int number_of_buffers() bool is_capturing() std::vector&lt; capture_format_t &gt; get_supported_formats() std::shared_ptr&lt; pixel_format_base &gt; get_pixel_format() usb_cam::utils::io_method_t get_io_method() size_t get_image_width() timespec get_image_timestamp() unsigned int get_image_step()Get number of bytes per line in image. size_t get_image_size_in_pixels() size_t get_image_size_in_bytes() size_t get_image_height() char * get_image()Take a new image with device and return it To copy the returned image to another format: sensor_msgs::msg::Image image_msg; auto new_image = get_image(); image_msg.data.resize(step * height); memcpy(&amp;image_msg.data[0], new_image-&gt;frame.base, image_msg.data.size());. void get_image(char * destination)Overload of get_image to allow users to pass in an image pointer to fill in. int get_fd() time_t get_epoch_time_shift_us() std::string get_device_name() std::shared_ptr&lt; usb_cam::utils::buffer[]&gt; get_buffers() AVDictionary * get_avoptions() AVFrame * get_avframe() AVCodecContext * get_avcodec_context() AVCodec * get_avcodec() void configure(parameters_t &amp; parameters, const io_method_t &amp; io_method)Configure device, should be called before start. UsbCam()"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-usbcam","title":"function ~UsbCam","text":"<pre><code>~UsbCam()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-supported_formats","title":"function supported_formats","text":"<pre><code>inline std::vector&lt; capture_format_t &gt; supported_formats()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-stop_capturing","title":"function stop_capturing","text":"<pre><code>void stop_capturing()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-start_capturing","title":"function start_capturing","text":"<pre><code>void start_capturing()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-start","title":"function start","text":"<pre><code>void start()\n</code></pre> <p>Start the configured device. </p>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-shutdown","title":"function shutdown","text":"<pre><code>void shutdown(\n    void \n)\n</code></pre> <p>shutdown camera </p>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-set_v4l_parameter","title":"function set_v4l_parameter","text":"<pre><code>bool set_v4l_parameter(\n    const std::string &amp; param,\n    int value\n)\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-set_v4l_parameter_1","title":"function set_v4l_parameter","text":"<pre><code>bool set_v4l_parameter(\n    const std::string &amp; param,\n    const std::string &amp; value\n)\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-set_pixel_format","title":"function set_pixel_format","text":"<pre><code>inline bool set_pixel_format(\n    const formats::format_arguments_t &amp; args\n)\n</code></pre> <p>Check if the given format is supported by this device If it is supported, set the m_pixel_format variable to it. </p> <p>Parameters: </p> <ul> <li>format the format to check if it is supported </li> </ul> <p>Return: bool true if the given format is supported, false otherwise </p>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-set_pixel_format_1","title":"function set_pixel_format","text":"<pre><code>inline std::shared_ptr&lt; pixel_format_base &gt; set_pixel_format(\n    const parameters_t &amp; parameters\n)\n</code></pre> <p>Set pixel format from parameter list. Required to have logic within UsbCam object in case pixel format class requires additional information for conversion function (e.g. number of pixels, width, height, etc.) </p> <p>Parameters: </p> <ul> <li>parameters list of parameters from which the pixel format is to be set </li> </ul> <p>Return: pixel format structure corresponding to a given name </p>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-set_auto_focus","title":"function set_auto_focus","text":"<pre><code>bool set_auto_focus(\n    int value\n)\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-number_of_buffers","title":"function number_of_buffers","text":"<pre><code>inline unsigned int number_of_buffers()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-is_capturing","title":"function is_capturing","text":"<pre><code>inline bool is_capturing()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-get_supported_formats","title":"function get_supported_formats","text":"<pre><code>std::vector&lt; capture_format_t &gt; get_supported_formats()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-get_pixel_format","title":"function get_pixel_format","text":"<pre><code>inline std::shared_ptr&lt; pixel_format_base &gt; get_pixel_format()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-get_io_method","title":"function get_io_method","text":"<pre><code>inline usb_cam::utils::io_method_t get_io_method()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-get_image_width","title":"function get_image_width","text":"<pre><code>inline size_t get_image_width()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-get_image_timestamp","title":"function get_image_timestamp","text":"<pre><code>inline timespec get_image_timestamp()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-get_image_step","title":"function get_image_step","text":"<pre><code>inline unsigned int get_image_step()\n</code></pre> <p>Get number of bytes per line in image. </p> <p>Return: number of bytes per line in image </p>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-get_image_size_in_pixels","title":"function get_image_size_in_pixels","text":"<pre><code>inline size_t get_image_size_in_pixels()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-get_image_size_in_bytes","title":"function get_image_size_in_bytes","text":"<pre><code>inline size_t get_image_size_in_bytes()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-get_image_height","title":"function get_image_height","text":"<pre><code>inline size_t get_image_height()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-get_image","title":"function get_image","text":"<pre><code>char * get_image()\n</code></pre> <p>Take a new image with device and return it To copy the returned image to another format: sensor_msgs::msg::Image image_msg; auto new_image = get_image(); image_msg.data.resize(step * height); memcpy(&amp;image_msg.data[0], new_image-&gt;frame.base, image_msg.data.size());. </p>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-get_image_1","title":"function get_image","text":"<pre><code>void get_image(\n    char * destination\n)\n</code></pre> <p>Overload of get_image to allow users to pass in an image pointer to fill in. </p>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-get_fd","title":"function get_fd","text":"<pre><code>inline int get_fd()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-get_epoch_time_shift_us","title":"function get_epoch_time_shift_us","text":"<pre><code>inline time_t get_epoch_time_shift_us()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-get_device_name","title":"function get_device_name","text":"<pre><code>inline std::string get_device_name()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-get_buffers","title":"function get_buffers","text":"<pre><code>inline std::shared_ptr&lt; usb_cam::utils::buffer[]&gt; get_buffers()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-get_avoptions","title":"function get_avoptions","text":"<pre><code>inline AVDictionary * get_avoptions()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-get_avframe","title":"function get_avframe","text":"<pre><code>inline AVFrame * get_avframe()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-get_avcodec_context","title":"function get_avcodec_context","text":"<pre><code>inline AVCodecContext * get_avcodec_context()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-get_avcodec","title":"function get_avcodec","text":"<pre><code>inline AVCodec * get_avcodec()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-configure","title":"function configure","text":"<pre><code>void configure(\n    parameters_t &amp; parameters,\n    const io_method_t &amp; io_method\n)\n</code></pre> <p>Configure device, should be called before start. </p>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCam/#function-usbcam_1","title":"function UsbCam","text":"<pre><code>UsbCam()\n</code></pre> <p>Updated on 2024-01-20 at 18:16:12 +0000</p>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCamNode/","title":"usb_cam::UsbCamNode","text":"<p>Inherits from rclcpp::Node</p>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCamNode/#public-functions","title":"Public Functions","text":"Name ~UsbCamNode() void update() bool take_and_send_image_mjpeg() bool take_and_send_image() void set_v4l2_params() void service_capture(const std::shared_ptr&lt; rmw_request_id_t &gt; request_header, const std::shared_ptr&lt; std_srvs::srv::SetBool::Request &gt; request, std::shared_ptr&lt; std_srvs::srv::SetBool::Response &gt; response) rcl_interfaces::msg::SetParametersResult parameters_callback(const std::vector&lt; rclcpp::Parameter &gt; &amp; parameters) void init() void get_params() void assign_params(const std::vector&lt; rclcpp::Parameter &gt; &amp; parameters) UsbCamNode(const rclcpp::NodeOptions &amp; node_options)"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCamNode/#public-attributes","title":"Public Attributes","text":"Name rclcpp::TimerBase::SharedPtr m_timer rclcpp::Service&lt; std_srvs::srv::SetBool &gt;::SharedPtr m_service_capture rclcpp::node_interfaces::OnSetParametersCallbackHandle::SharedPtr m_parameters_callback_handle parameters_t m_parameters std::shared_ptr&lt; image_transport::CameraPublisher &gt; m_image_publisher sensor_msgs::msg::Image::UniquePtr m_image_msg sensor_msgs::msg::CompressedImage::UniquePtr m_compressed_img_msg rclcpp::Publisher&lt; sensor_msgs::msg::CompressedImage &gt;::SharedPtr m_compressed_image_publisher rclcpp::Publisher&lt; sensor_msgs::msg::CameraInfo &gt;::SharedPtr m_compressed_cam_info_publisher sensor_msgs::msg::CameraInfo::SharedPtr m_camera_info_msg std::shared_ptr&lt; camera_info_manager::CameraInfoManager &gt; m_camera_info UsbCam * m_camera"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCamNode/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api-reference/Classes/classusb__cam_1_1UsbCamNode/#function-usbcamnode","title":"function ~UsbCamNode","text":"<pre><code>~UsbCamNode()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCamNode/#function-update","title":"function update","text":"<pre><code>void update()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCamNode/#function-take_and_send_image_mjpeg","title":"function take_and_send_image_mjpeg","text":"<pre><code>bool take_and_send_image_mjpeg()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCamNode/#function-take_and_send_image","title":"function take_and_send_image","text":"<pre><code>bool take_and_send_image()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCamNode/#function-set_v4l2_params","title":"function set_v4l2_params","text":"<pre><code>void set_v4l2_params()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCamNode/#function-service_capture","title":"function service_capture","text":"<pre><code>void service_capture(\n    const std::shared_ptr&lt; rmw_request_id_t &gt; request_header,\n    const std::shared_ptr&lt; std_srvs::srv::SetBool::Request &gt; request,\n    std::shared_ptr&lt; std_srvs::srv::SetBool::Response &gt; response\n)\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCamNode/#function-parameters_callback","title":"function parameters_callback","text":"<pre><code>rcl_interfaces::msg::SetParametersResult parameters_callback(\n    const std::vector&lt; rclcpp::Parameter &gt; &amp; parameters\n)\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCamNode/#function-init","title":"function init","text":"<pre><code>void init()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCamNode/#function-get_params","title":"function get_params","text":"<pre><code>void get_params()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCamNode/#function-assign_params","title":"function assign_params","text":"<pre><code>void assign_params(\n    const std::vector&lt; rclcpp::Parameter &gt; &amp; parameters\n)\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCamNode/#function-usbcamnode_1","title":"function UsbCamNode","text":"<pre><code>explicit UsbCamNode(\n    const rclcpp::NodeOptions &amp; node_options\n)\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCamNode/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api-reference/Classes/classusb__cam_1_1UsbCamNode/#variable-m_timer","title":"variable m_timer","text":"<pre><code>rclcpp::TimerBase::SharedPtr m_timer;\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCamNode/#variable-m_service_capture","title":"variable m_service_capture","text":"<pre><code>rclcpp::Service&lt; std_srvs::srv::SetBool &gt;::SharedPtr m_service_capture;\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCamNode/#variable-m_parameters_callback_handle","title":"variable m_parameters_callback_handle","text":"<pre><code>rclcpp::node_interfaces::OnSetParametersCallbackHandle::SharedPtr m_parameters_callback_handle;\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCamNode/#variable-m_parameters","title":"variable m_parameters","text":"<pre><code>parameters_t m_parameters;\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCamNode/#variable-m_image_publisher","title":"variable m_image_publisher","text":"<pre><code>std::shared_ptr&lt; image_transport::CameraPublisher &gt; m_image_publisher;\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCamNode/#variable-m_image_msg","title":"variable m_image_msg","text":"<pre><code>sensor_msgs::msg::Image::UniquePtr m_image_msg;\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCamNode/#variable-m_compressed_img_msg","title":"variable m_compressed_img_msg","text":"<pre><code>sensor_msgs::msg::CompressedImage::UniquePtr m_compressed_img_msg;\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCamNode/#variable-m_compressed_image_publisher","title":"variable m_compressed_image_publisher","text":"<pre><code>rclcpp::Publisher&lt; sensor_msgs::msg::CompressedImage &gt;::SharedPtr m_compressed_image_publisher;\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCamNode/#variable-m_compressed_cam_info_publisher","title":"variable m_compressed_cam_info_publisher","text":"<pre><code>rclcpp::Publisher&lt; sensor_msgs::msg::CameraInfo &gt;::SharedPtr m_compressed_cam_info_publisher;\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCamNode/#variable-m_camera_info_msg","title":"variable m_camera_info_msg","text":"<pre><code>sensor_msgs::msg::CameraInfo::SharedPtr m_camera_info_msg;\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCamNode/#variable-m_camera_info","title":"variable m_camera_info","text":"<pre><code>std::shared_ptr&lt; camera_info_manager::CameraInfoManager &gt; m_camera_info;\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1UsbCamNode/#variable-m_camera","title":"variable m_camera","text":"<pre><code>UsbCam * m_camera;\n</code></pre> <p>Updated on 2024-01-20 at 18:16:12 +0000</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1M4202RGB/","title":"usb_cam::formats::M4202RGB","text":"<p>Inherits from usb_cam::formats::pixel_format_base</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1M4202RGB/#public-functions","title":"Public Functions","text":"Name virtual void convert(const char &amp; src, char &amp; dest, const int &amp; bytes_used) overrideConvert a YUV420 (aka M420) image to RGB8. M4202RGB(const format_arguments_t &amp; args =format_arguments_t())"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1M4202RGB/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from usb_cam::formats::pixel_format_base</p> Name std::string v4l2_str()String value of V4L2 capture pixel format. uint32_t v4l2()Integer value of V4L2 capture pixel format. std::string ros()Name of output pixel (encoding) format to ROS. bool requires_conversion()True if the current pixel format requires a call to the <code>convert</code> method Used in the usb_cam library logic to determine if a plain <code>memcopy</code> call can be used instead of a call to the <code>convert</code> method of this class. pixel_format_base(std::string name, uint32_t v4l2, std::string ros, uint8_t channels, uint8_t bit_depth, bool requires_conversion) std::string name()Name of pixel format. Used in the parameters file to select this format. bool is_mono()Returns if the final output format is monocolor (gray) Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool is_color()Returns if the final output format is color Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool is_bayer()Returns if the final output format is bayer Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool has_alpha()Returns if the final output format has an alpha value Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. uint8_t channels()Number of channels (e.g. bytes) per pixel. uint8_t byte_depth()Number of bytes per channel. uint8_t bit_depth()Number for bit depth of image. <p>Protected Attributes inherited from usb_cam::formats::pixel_format_base</p> Name uint32_t m_v4l2 Integer correspoding to a specific V4L2_PIX_FMT_* constant See <code>linux/videodev2.h</code> for a list of all possible values for here. std::string m_ros This should match ROS encoding string See <code>sensor_msgs/image_encodings.hpp</code> for corresponding possible values. Copy of those values are stored in <code>[usb_cam/constants.hpp]</code> bool m_requires_conversion boolean whether or not the current format requires a call to <code>convert</code>. Setting this to true requires that the virtual <code>convert</code> method is implemented. std::string m_name Unique name for this pixel format. uint8_t m_channels Number of channels (aka bytes per pixel) of output (ROS format above) uint8_t m_bit_depth Bitdepth of output (ROS format above)"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1M4202RGB/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1M4202RGB/#function-convert","title":"function convert","text":"<pre><code>inline virtual void convert(\n    const char *&amp; src,\n    char *&amp; dest,\n    const int &amp; bytes_used\n) override\n</code></pre> <p>Convert a YUV420 (aka M420) image to RGB8. </p> <p>Reimplements: usb_cam::formats::pixel_format_base::convert</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1M4202RGB/#function-m4202rgb","title":"function M4202RGB","text":"<pre><code>inline explicit M4202RGB(\n    const format_arguments_t &amp; args =format_arguments_t()\n)\n</code></pre> <p>Updated on 2024-01-20 at 18:16:12 +0000</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1MJPEG2RGB/","title":"usb_cam::formats::MJPEG2RGB","text":"<p>Inherits from usb_cam::formats::pixel_format_base</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1MJPEG2RGB/#public-functions","title":"Public Functions","text":"Name ~MJPEG2RGB() virtual void convert(const char &amp; src, char &amp; dest, const int &amp; bytes_used) overrideConversion method. Meant to be overridden if pixel format requires it. MJPEG2RGB(const format_arguments_t &amp; args =format_arguments_t())"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1MJPEG2RGB/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from usb_cam::formats::pixel_format_base</p> Name std::string v4l2_str()String value of V4L2 capture pixel format. uint32_t v4l2()Integer value of V4L2 capture pixel format. std::string ros()Name of output pixel (encoding) format to ROS. bool requires_conversion()True if the current pixel format requires a call to the <code>convert</code> method Used in the usb_cam library logic to determine if a plain <code>memcopy</code> call can be used instead of a call to the <code>convert</code> method of this class. pixel_format_base(std::string name, uint32_t v4l2, std::string ros, uint8_t channels, uint8_t bit_depth, bool requires_conversion) std::string name()Name of pixel format. Used in the parameters file to select this format. bool is_mono()Returns if the final output format is monocolor (gray) Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool is_color()Returns if the final output format is color Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool is_bayer()Returns if the final output format is bayer Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool has_alpha()Returns if the final output format has an alpha value Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. uint8_t channels()Number of channels (e.g. bytes) per pixel. uint8_t byte_depth()Number of bytes per channel. uint8_t bit_depth()Number for bit depth of image. <p>Protected Attributes inherited from usb_cam::formats::pixel_format_base</p> Name uint32_t m_v4l2 Integer correspoding to a specific V4L2_PIX_FMT_* constant See <code>linux/videodev2.h</code> for a list of all possible values for here. std::string m_ros This should match ROS encoding string See <code>sensor_msgs/image_encodings.hpp</code> for corresponding possible values. Copy of those values are stored in <code>[usb_cam/constants.hpp]</code> bool m_requires_conversion boolean whether or not the current format requires a call to <code>convert</code>. Setting this to true requires that the virtual <code>convert</code> method is implemented. std::string m_name Unique name for this pixel format. uint8_t m_channels Number of channels (aka bytes per pixel) of output (ROS format above) uint8_t m_bit_depth Bitdepth of output (ROS format above)"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1MJPEG2RGB/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1MJPEG2RGB/#function-mjpeg2rgb","title":"function ~MJPEG2RGB","text":"<pre><code>inline ~MJPEG2RGB()\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1MJPEG2RGB/#function-convert","title":"function convert","text":"<pre><code>inline virtual void convert(\n    const char *&amp; src,\n    char *&amp; dest,\n    const int &amp; bytes_used\n) override\n</code></pre> <p>Conversion method. Meant to be overridden if pixel format requires it. </p> <p>Reimplements: usb_cam::formats::pixel_format_base::convert</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1MJPEG2RGB/#function-mjpeg2rgb_1","title":"function MJPEG2RGB","text":"<pre><code>inline explicit MJPEG2RGB(\n    const format_arguments_t &amp; args =format_arguments_t()\n)\n</code></pre> <p>Updated on 2024-01-20 at 18:16:12 +0000</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1MONO16/","title":"usb_cam::formats::MONO16","text":"<p>Inherits from usb_cam::formats::pixel_format_base</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1MONO16/#public-functions","title":"Public Functions","text":"Name MONO16(const format_arguments_t &amp; args =format_arguments_t())"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1MONO16/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from usb_cam::formats::pixel_format_base</p> Name std::string v4l2_str()String value of V4L2 capture pixel format. uint32_t v4l2()Integer value of V4L2 capture pixel format. std::string ros()Name of output pixel (encoding) format to ROS. bool requires_conversion()True if the current pixel format requires a call to the <code>convert</code> method Used in the usb_cam library logic to determine if a plain <code>memcopy</code> call can be used instead of a call to the <code>convert</code> method of this class. pixel_format_base(std::string name, uint32_t v4l2, std::string ros, uint8_t channels, uint8_t bit_depth, bool requires_conversion) std::string name()Name of pixel format. Used in the parameters file to select this format. bool is_mono()Returns if the final output format is monocolor (gray) Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool is_color()Returns if the final output format is color Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool is_bayer()Returns if the final output format is bayer Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool has_alpha()Returns if the final output format has an alpha value Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. virtual void convert(const char &amp; src, char &amp; dest, const int &amp; bytes_used)Conversion method. Meant to be overridden if pixel format requires it. uint8_t channels()Number of channels (e.g. bytes) per pixel. uint8_t byte_depth()Number of bytes per channel. uint8_t bit_depth()Number for bit depth of image. <p>Protected Attributes inherited from usb_cam::formats::pixel_format_base</p> Name uint32_t m_v4l2 Integer correspoding to a specific V4L2_PIX_FMT_* constant See <code>linux/videodev2.h</code> for a list of all possible values for here. std::string m_ros This should match ROS encoding string See <code>sensor_msgs/image_encodings.hpp</code> for corresponding possible values. Copy of those values are stored in <code>[usb_cam/constants.hpp]</code> bool m_requires_conversion boolean whether or not the current format requires a call to <code>convert</code>. Setting this to true requires that the virtual <code>convert</code> method is implemented. std::string m_name Unique name for this pixel format. uint8_t m_channels Number of channels (aka bytes per pixel) of output (ROS format above) uint8_t m_bit_depth Bitdepth of output (ROS format above)"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1MONO16/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1MONO16/#function-mono16","title":"function MONO16","text":"<pre><code>inline explicit MONO16(\n    const format_arguments_t &amp; args =format_arguments_t()\n)\n</code></pre> <p>Updated on 2024-01-20 at 18:16:12 +0000</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1MONO8/","title":"usb_cam::formats::MONO8","text":"<p>Inherits from usb_cam::formats::pixel_format_base</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1MONO8/#public-functions","title":"Public Functions","text":"Name MONO8(const format_arguments_t &amp; args =format_arguments_t())"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1MONO8/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from usb_cam::formats::pixel_format_base</p> Name std::string v4l2_str()String value of V4L2 capture pixel format. uint32_t v4l2()Integer value of V4L2 capture pixel format. std::string ros()Name of output pixel (encoding) format to ROS. bool requires_conversion()True if the current pixel format requires a call to the <code>convert</code> method Used in the usb_cam library logic to determine if a plain <code>memcopy</code> call can be used instead of a call to the <code>convert</code> method of this class. pixel_format_base(std::string name, uint32_t v4l2, std::string ros, uint8_t channels, uint8_t bit_depth, bool requires_conversion) std::string name()Name of pixel format. Used in the parameters file to select this format. bool is_mono()Returns if the final output format is monocolor (gray) Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool is_color()Returns if the final output format is color Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool is_bayer()Returns if the final output format is bayer Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool has_alpha()Returns if the final output format has an alpha value Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. virtual void convert(const char &amp; src, char &amp; dest, const int &amp; bytes_used)Conversion method. Meant to be overridden if pixel format requires it. uint8_t channels()Number of channels (e.g. bytes) per pixel. uint8_t byte_depth()Number of bytes per channel. uint8_t bit_depth()Number for bit depth of image. <p>Protected Attributes inherited from usb_cam::formats::pixel_format_base</p> Name uint32_t m_v4l2 Integer correspoding to a specific V4L2_PIX_FMT_* constant See <code>linux/videodev2.h</code> for a list of all possible values for here. std::string m_ros This should match ROS encoding string See <code>sensor_msgs/image_encodings.hpp</code> for corresponding possible values. Copy of those values are stored in <code>[usb_cam/constants.hpp]</code> bool m_requires_conversion boolean whether or not the current format requires a call to <code>convert</code>. Setting this to true requires that the virtual <code>convert</code> method is implemented. std::string m_name Unique name for this pixel format. uint8_t m_channels Number of channels (aka bytes per pixel) of output (ROS format above) uint8_t m_bit_depth Bitdepth of output (ROS format above)"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1MONO8/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1MONO8/#function-mono8","title":"function MONO8","text":"<pre><code>inline explicit MONO8(\n    const format_arguments_t &amp; args =format_arguments_t()\n)\n</code></pre> <p>Updated on 2024-01-20 at 18:16:12 +0000</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1RAW__MJPEG/","title":"usb_cam::formats::RAW_MJPEG","text":"<p>Inherits from usb_cam::formats::pixel_format_base</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1RAW__MJPEG/#public-functions","title":"Public Functions","text":"Name RAW_MJPEG(const format_arguments_t &amp; args =format_arguments_t())"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1RAW__MJPEG/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from usb_cam::formats::pixel_format_base</p> Name std::string v4l2_str()String value of V4L2 capture pixel format. uint32_t v4l2()Integer value of V4L2 capture pixel format. std::string ros()Name of output pixel (encoding) format to ROS. bool requires_conversion()True if the current pixel format requires a call to the <code>convert</code> method Used in the usb_cam library logic to determine if a plain <code>memcopy</code> call can be used instead of a call to the <code>convert</code> method of this class. pixel_format_base(std::string name, uint32_t v4l2, std::string ros, uint8_t channels, uint8_t bit_depth, bool requires_conversion) std::string name()Name of pixel format. Used in the parameters file to select this format. bool is_mono()Returns if the final output format is monocolor (gray) Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool is_color()Returns if the final output format is color Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool is_bayer()Returns if the final output format is bayer Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool has_alpha()Returns if the final output format has an alpha value Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. virtual void convert(const char &amp; src, char &amp; dest, const int &amp; bytes_used)Conversion method. Meant to be overridden if pixel format requires it. uint8_t channels()Number of channels (e.g. bytes) per pixel. uint8_t byte_depth()Number of bytes per channel. uint8_t bit_depth()Number for bit depth of image. <p>Protected Attributes inherited from usb_cam::formats::pixel_format_base</p> Name uint32_t m_v4l2 Integer correspoding to a specific V4L2_PIX_FMT_* constant See <code>linux/videodev2.h</code> for a list of all possible values for here. std::string m_ros This should match ROS encoding string See <code>sensor_msgs/image_encodings.hpp</code> for corresponding possible values. Copy of those values are stored in <code>[usb_cam/constants.hpp]</code> bool m_requires_conversion boolean whether or not the current format requires a call to <code>convert</code>. Setting this to true requires that the virtual <code>convert</code> method is implemented. std::string m_name Unique name for this pixel format. uint8_t m_channels Number of channels (aka bytes per pixel) of output (ROS format above) uint8_t m_bit_depth Bitdepth of output (ROS format above)"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1RAW__MJPEG/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1RAW__MJPEG/#function-raw_mjpeg","title":"function RAW_MJPEG","text":"<pre><code>inline explicit RAW_MJPEG(\n    const format_arguments_t &amp; args =format_arguments_t()\n)\n</code></pre> <p>Updated on 2024-01-20 at 18:16:12 +0000</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1RGB8/","title":"usb_cam::formats::RGB8","text":"<p>Inherits from usb_cam::formats::pixel_format_base</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1RGB8/#public-functions","title":"Public Functions","text":"Name RGB8(const format_arguments_t &amp; args =format_arguments_t())"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1RGB8/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from usb_cam::formats::pixel_format_base</p> Name std::string v4l2_str()String value of V4L2 capture pixel format. uint32_t v4l2()Integer value of V4L2 capture pixel format. std::string ros()Name of output pixel (encoding) format to ROS. bool requires_conversion()True if the current pixel format requires a call to the <code>convert</code> method Used in the usb_cam library logic to determine if a plain <code>memcopy</code> call can be used instead of a call to the <code>convert</code> method of this class. pixel_format_base(std::string name, uint32_t v4l2, std::string ros, uint8_t channels, uint8_t bit_depth, bool requires_conversion) std::string name()Name of pixel format. Used in the parameters file to select this format. bool is_mono()Returns if the final output format is monocolor (gray) Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool is_color()Returns if the final output format is color Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool is_bayer()Returns if the final output format is bayer Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool has_alpha()Returns if the final output format has an alpha value Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. virtual void convert(const char &amp; src, char &amp; dest, const int &amp; bytes_used)Conversion method. Meant to be overridden if pixel format requires it. uint8_t channels()Number of channels (e.g. bytes) per pixel. uint8_t byte_depth()Number of bytes per channel. uint8_t bit_depth()Number for bit depth of image. <p>Protected Attributes inherited from usb_cam::formats::pixel_format_base</p> Name uint32_t m_v4l2 Integer correspoding to a specific V4L2_PIX_FMT_* constant See <code>linux/videodev2.h</code> for a list of all possible values for here. std::string m_ros This should match ROS encoding string See <code>sensor_msgs/image_encodings.hpp</code> for corresponding possible values. Copy of those values are stored in <code>[usb_cam/constants.hpp]</code> bool m_requires_conversion boolean whether or not the current format requires a call to <code>convert</code>. Setting this to true requires that the virtual <code>convert</code> method is implemented. std::string m_name Unique name for this pixel format. uint8_t m_channels Number of channels (aka bytes per pixel) of output (ROS format above) uint8_t m_bit_depth Bitdepth of output (ROS format above)"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1RGB8/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1RGB8/#function-rgb8","title":"function RGB8","text":"<pre><code>inline explicit RGB8(\n    const format_arguments_t &amp; args =format_arguments_t()\n)\n</code></pre> <p>Updated on 2024-01-20 at 18:16:12 +0000</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1UYVY/","title":"usb_cam::formats::UYVY","text":"<p>Inherits from usb_cam::formats::pixel_format_base</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1UYVY/#public-functions","title":"Public Functions","text":"Name UYVY(const format_arguments_t &amp; args =format_arguments_t())"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1UYVY/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from usb_cam::formats::pixel_format_base</p> Name std::string v4l2_str()String value of V4L2 capture pixel format. uint32_t v4l2()Integer value of V4L2 capture pixel format. std::string ros()Name of output pixel (encoding) format to ROS. bool requires_conversion()True if the current pixel format requires a call to the <code>convert</code> method Used in the usb_cam library logic to determine if a plain <code>memcopy</code> call can be used instead of a call to the <code>convert</code> method of this class. pixel_format_base(std::string name, uint32_t v4l2, std::string ros, uint8_t channels, uint8_t bit_depth, bool requires_conversion) std::string name()Name of pixel format. Used in the parameters file to select this format. bool is_mono()Returns if the final output format is monocolor (gray) Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool is_color()Returns if the final output format is color Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool is_bayer()Returns if the final output format is bayer Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool has_alpha()Returns if the final output format has an alpha value Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. virtual void convert(const char &amp; src, char &amp; dest, const int &amp; bytes_used)Conversion method. Meant to be overridden if pixel format requires it. uint8_t channels()Number of channels (e.g. bytes) per pixel. uint8_t byte_depth()Number of bytes per channel. uint8_t bit_depth()Number for bit depth of image. <p>Protected Attributes inherited from usb_cam::formats::pixel_format_base</p> Name uint32_t m_v4l2 Integer correspoding to a specific V4L2_PIX_FMT_* constant See <code>linux/videodev2.h</code> for a list of all possible values for here. std::string m_ros This should match ROS encoding string See <code>sensor_msgs/image_encodings.hpp</code> for corresponding possible values. Copy of those values are stored in <code>[usb_cam/constants.hpp]</code> bool m_requires_conversion boolean whether or not the current format requires a call to <code>convert</code>. Setting this to true requires that the virtual <code>convert</code> method is implemented. std::string m_name Unique name for this pixel format. uint8_t m_channels Number of channels (aka bytes per pixel) of output (ROS format above) uint8_t m_bit_depth Bitdepth of output (ROS format above)"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1UYVY/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1UYVY/#function-uyvy","title":"function UYVY","text":"<pre><code>inline explicit UYVY(\n    const format_arguments_t &amp; args =format_arguments_t()\n)\n</code></pre> <p>Updated on 2024-01-20 at 18:16:12 +0000</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1UYVY2RGB/","title":"usb_cam::formats::UYVY2RGB","text":"<p>Inherits from usb_cam::formats::pixel_format_base</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1UYVY2RGB/#public-functions","title":"Public Functions","text":"Name virtual void convert(const char &amp; src, char &amp; dest, const int &amp; bytes_used) overrideIn this format each four bytes is two pixels. Each four bytes is two Y's, a Cb and a Cr. Each Y goes to one of the pixels, and the Cb and Cr belong to both pixels. As you can see, the Cr and Cb components have half the horizontal resolution of the Y component. V4L2_PIX_FMT_UYVY is known in the Windows environment as YUY2. UYVY2RGB(const format_arguments_t &amp; args =format_arguments_t())"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1UYVY2RGB/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from usb_cam::formats::pixel_format_base</p> Name std::string v4l2_str()String value of V4L2 capture pixel format. uint32_t v4l2()Integer value of V4L2 capture pixel format. std::string ros()Name of output pixel (encoding) format to ROS. bool requires_conversion()True if the current pixel format requires a call to the <code>convert</code> method Used in the usb_cam library logic to determine if a plain <code>memcopy</code> call can be used instead of a call to the <code>convert</code> method of this class. pixel_format_base(std::string name, uint32_t v4l2, std::string ros, uint8_t channels, uint8_t bit_depth, bool requires_conversion) std::string name()Name of pixel format. Used in the parameters file to select this format. bool is_mono()Returns if the final output format is monocolor (gray) Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool is_color()Returns if the final output format is color Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool is_bayer()Returns if the final output format is bayer Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool has_alpha()Returns if the final output format has an alpha value Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. uint8_t channels()Number of channels (e.g. bytes) per pixel. uint8_t byte_depth()Number of bytes per channel. uint8_t bit_depth()Number for bit depth of image. <p>Protected Attributes inherited from usb_cam::formats::pixel_format_base</p> Name uint32_t m_v4l2 Integer correspoding to a specific V4L2_PIX_FMT_* constant See <code>linux/videodev2.h</code> for a list of all possible values for here. std::string m_ros This should match ROS encoding string See <code>sensor_msgs/image_encodings.hpp</code> for corresponding possible values. Copy of those values are stored in <code>[usb_cam/constants.hpp]</code> bool m_requires_conversion boolean whether or not the current format requires a call to <code>convert</code>. Setting this to true requires that the virtual <code>convert</code> method is implemented. std::string m_name Unique name for this pixel format. uint8_t m_channels Number of channels (aka bytes per pixel) of output (ROS format above) uint8_t m_bit_depth Bitdepth of output (ROS format above)"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1UYVY2RGB/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1UYVY2RGB/#function-convert","title":"function convert","text":"<pre><code>inline virtual void convert(\n    const char *&amp; src,\n    char *&amp; dest,\n    const int &amp; bytes_used\n) override\n</code></pre> <p>In this format each four bytes is two pixels. Each four bytes is two Y's, a Cb and a Cr. Each Y goes to one of the pixels, and the Cb and Cr belong to both pixels. As you can see, the Cr and Cb components have half the horizontal resolution of the Y component. V4L2_PIX_FMT_UYVY is known in the Windows environment as YUY2. </p> <p>Reimplements: usb_cam::formats::pixel_format_base::convert</p> <p>Source: https://www.linuxtv.org/downloads/v4l-dvb-apis-old/V4L2-PIX-FMT-YUYV.html</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1UYVY2RGB/#function-uyvy2rgb","title":"function UYVY2RGB","text":"<pre><code>inline explicit UYVY2RGB(\n    const format_arguments_t &amp; args =format_arguments_t()\n)\n</code></pre> <p>Updated on 2024-01-20 at 18:16:12 +0000</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1Y102MONO8/","title":"usb_cam::formats::Y102MONO8","text":"<p>Also known as MONO10 to MONO8. </p> <p><code>#include &lt;mono.hpp&gt;</code></p> <p>Inherits from usb_cam::formats::pixel_format_base</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1Y102MONO8/#public-functions","title":"Public Functions","text":"Name virtual void convert(const char &amp; src, char &amp; dest, const int &amp; bytes_used) overrideConvert a Y10 (MONO10) image to MONO8. Y102MONO8(const format_arguments_t &amp; args =format_arguments_t())"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1Y102MONO8/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from usb_cam::formats::pixel_format_base</p> Name std::string v4l2_str()String value of V4L2 capture pixel format. uint32_t v4l2()Integer value of V4L2 capture pixel format. std::string ros()Name of output pixel (encoding) format to ROS. bool requires_conversion()True if the current pixel format requires a call to the <code>convert</code> method Used in the usb_cam library logic to determine if a plain <code>memcopy</code> call can be used instead of a call to the <code>convert</code> method of this class. pixel_format_base(std::string name, uint32_t v4l2, std::string ros, uint8_t channels, uint8_t bit_depth, bool requires_conversion) std::string name()Name of pixel format. Used in the parameters file to select this format. bool is_mono()Returns if the final output format is monocolor (gray) Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool is_color()Returns if the final output format is color Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool is_bayer()Returns if the final output format is bayer Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool has_alpha()Returns if the final output format has an alpha value Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. uint8_t channels()Number of channels (e.g. bytes) per pixel. uint8_t byte_depth()Number of bytes per channel. uint8_t bit_depth()Number for bit depth of image. <p>Protected Attributes inherited from usb_cam::formats::pixel_format_base</p> Name uint32_t m_v4l2 Integer correspoding to a specific V4L2_PIX_FMT_* constant See <code>linux/videodev2.h</code> for a list of all possible values for here. std::string m_ros This should match ROS encoding string See <code>sensor_msgs/image_encodings.hpp</code> for corresponding possible values. Copy of those values are stored in <code>[usb_cam/constants.hpp]</code> bool m_requires_conversion boolean whether or not the current format requires a call to <code>convert</code>. Setting this to true requires that the virtual <code>convert</code> method is implemented. std::string m_name Unique name for this pixel format. uint8_t m_channels Number of channels (aka bytes per pixel) of output (ROS format above) uint8_t m_bit_depth Bitdepth of output (ROS format above)"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1Y102MONO8/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1Y102MONO8/#function-convert","title":"function convert","text":"<pre><code>inline virtual void convert(\n    const char *&amp; src,\n    char *&amp; dest,\n    const int &amp; bytes_used\n) override\n</code></pre> <p>Convert a Y10 (MONO10) image to MONO8. </p> <p>Parameters: </p> <ul> <li>src pointer to source Y10 (MONO10) image </li> <li>dest pointer to destination MONO8 image </li> <li>bytes_used number of bytes used by source image </li> </ul> <p>Reimplements: usb_cam::formats::pixel_format_base::convert</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1Y102MONO8/#function-y102mono8","title":"function Y102MONO8","text":"<pre><code>inline explicit Y102MONO8(\n    const format_arguments_t &amp; args =format_arguments_t()\n)\n</code></pre> <p>Updated on 2024-01-20 at 18:16:12 +0000</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1YUYV/","title":"usb_cam::formats::YUYV","text":"<p>Inherits from usb_cam::formats::pixel_format_base</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1YUYV/#public-functions","title":"Public Functions","text":"Name YUYV(const format_arguments_t &amp; args =format_arguments_t())"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1YUYV/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from usb_cam::formats::pixel_format_base</p> Name std::string v4l2_str()String value of V4L2 capture pixel format. uint32_t v4l2()Integer value of V4L2 capture pixel format. std::string ros()Name of output pixel (encoding) format to ROS. bool requires_conversion()True if the current pixel format requires a call to the <code>convert</code> method Used in the usb_cam library logic to determine if a plain <code>memcopy</code> call can be used instead of a call to the <code>convert</code> method of this class. pixel_format_base(std::string name, uint32_t v4l2, std::string ros, uint8_t channels, uint8_t bit_depth, bool requires_conversion) std::string name()Name of pixel format. Used in the parameters file to select this format. bool is_mono()Returns if the final output format is monocolor (gray) Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool is_color()Returns if the final output format is color Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool is_bayer()Returns if the final output format is bayer Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool has_alpha()Returns if the final output format has an alpha value Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. virtual void convert(const char &amp; src, char &amp; dest, const int &amp; bytes_used)Conversion method. Meant to be overridden if pixel format requires it. uint8_t channels()Number of channels (e.g. bytes) per pixel. uint8_t byte_depth()Number of bytes per channel. uint8_t bit_depth()Number for bit depth of image. <p>Protected Attributes inherited from usb_cam::formats::pixel_format_base</p> Name uint32_t m_v4l2 Integer correspoding to a specific V4L2_PIX_FMT_* constant See <code>linux/videodev2.h</code> for a list of all possible values for here. std::string m_ros This should match ROS encoding string See <code>sensor_msgs/image_encodings.hpp</code> for corresponding possible values. Copy of those values are stored in <code>[usb_cam/constants.hpp]</code> bool m_requires_conversion boolean whether or not the current format requires a call to <code>convert</code>. Setting this to true requires that the virtual <code>convert</code> method is implemented. std::string m_name Unique name for this pixel format. uint8_t m_channels Number of channels (aka bytes per pixel) of output (ROS format above) uint8_t m_bit_depth Bitdepth of output (ROS format above)"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1YUYV/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1YUYV/#function-yuyv","title":"function YUYV","text":"<pre><code>inline explicit YUYV(\n    const format_arguments_t &amp; args =format_arguments_t()\n)\n</code></pre> <p>Updated on 2024-01-20 at 18:16:12 +0000</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1YUYV2RGB/","title":"usb_cam::formats::YUYV2RGB","text":"<p>Inherits from usb_cam::formats::pixel_format_base</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1YUYV2RGB/#public-functions","title":"Public Functions","text":"Name virtual void convert(const char &amp; src, char &amp; dest, const int &amp; bytes_used) overrideIn this format each four bytes is two pixels. Each four bytes is two Y's, a Cb and a Cr. Each Y goes to one of the pixels, and the Cb and Cr belong to both pixels. As you can see, the Cr and Cb components have half the horizontal resolution of the Y component. V4L2_PIX_FMT_YUYV is known in the Windows environment as YUY2. YUYV2RGB(const format_arguments_t &amp; args =format_arguments_t())"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1YUYV2RGB/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from usb_cam::formats::pixel_format_base</p> Name std::string v4l2_str()String value of V4L2 capture pixel format. uint32_t v4l2()Integer value of V4L2 capture pixel format. std::string ros()Name of output pixel (encoding) format to ROS. bool requires_conversion()True if the current pixel format requires a call to the <code>convert</code> method Used in the usb_cam library logic to determine if a plain <code>memcopy</code> call can be used instead of a call to the <code>convert</code> method of this class. pixel_format_base(std::string name, uint32_t v4l2, std::string ros, uint8_t channels, uint8_t bit_depth, bool requires_conversion) std::string name()Name of pixel format. Used in the parameters file to select this format. bool is_mono()Returns if the final output format is monocolor (gray) Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool is_color()Returns if the final output format is color Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool is_bayer()Returns if the final output format is bayer Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool has_alpha()Returns if the final output format has an alpha value Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. uint8_t channels()Number of channels (e.g. bytes) per pixel. uint8_t byte_depth()Number of bytes per channel. uint8_t bit_depth()Number for bit depth of image. <p>Protected Attributes inherited from usb_cam::formats::pixel_format_base</p> Name uint32_t m_v4l2 Integer correspoding to a specific V4L2_PIX_FMT_* constant See <code>linux/videodev2.h</code> for a list of all possible values for here. std::string m_ros This should match ROS encoding string See <code>sensor_msgs/image_encodings.hpp</code> for corresponding possible values. Copy of those values are stored in <code>[usb_cam/constants.hpp]</code> bool m_requires_conversion boolean whether or not the current format requires a call to <code>convert</code>. Setting this to true requires that the virtual <code>convert</code> method is implemented. std::string m_name Unique name for this pixel format. uint8_t m_channels Number of channels (aka bytes per pixel) of output (ROS format above) uint8_t m_bit_depth Bitdepth of output (ROS format above)"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1YUYV2RGB/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1YUYV2RGB/#function-convert","title":"function convert","text":"<pre><code>inline virtual void convert(\n    const char *&amp; src,\n    char *&amp; dest,\n    const int &amp; bytes_used\n) override\n</code></pre> <p>In this format each four bytes is two pixels. Each four bytes is two Y's, a Cb and a Cr. Each Y goes to one of the pixels, and the Cb and Cr belong to both pixels. As you can see, the Cr and Cb components have half the horizontal resolution of the Y component. V4L2_PIX_FMT_YUYV is known in the Windows environment as YUY2. </p> <p>Reimplements: usb_cam::formats::pixel_format_base::convert</p> <p>Source: https://www.linuxtv.org/downloads/v4l-dvb-apis-old/V4L2-PIX-FMT-YUYV.html</p> <p>Total number of bytes should be 2 * number of pixels. Achieve this by bit-shifting (NumPixels &lt;&lt; 1). See format description above.</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1YUYV2RGB/#function-yuyv2rgb","title":"function YUYV2RGB","text":"<pre><code>inline explicit YUYV2RGB(\n    const format_arguments_t &amp; args =format_arguments_t()\n)\n</code></pre> <p>Updated on 2024-01-20 at 18:16:12 +0000</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1default__pixel__format/","title":"usb_cam::formats::default_pixel_format","text":"<p>Inherits from usb_cam::formats::pixel_format_base</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1default__pixel__format/#public-functions","title":"Public Functions","text":"Name default_pixel_format()"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1default__pixel__format/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from usb_cam::formats::pixel_format_base</p> Name std::string v4l2_str()String value of V4L2 capture pixel format. uint32_t v4l2()Integer value of V4L2 capture pixel format. std::string ros()Name of output pixel (encoding) format to ROS. bool requires_conversion()True if the current pixel format requires a call to the <code>convert</code> method Used in the usb_cam library logic to determine if a plain <code>memcopy</code> call can be used instead of a call to the <code>convert</code> method of this class. pixel_format_base(std::string name, uint32_t v4l2, std::string ros, uint8_t channels, uint8_t bit_depth, bool requires_conversion) std::string name()Name of pixel format. Used in the parameters file to select this format. bool is_mono()Returns if the final output format is monocolor (gray) Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool is_color()Returns if the final output format is color Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool is_bayer()Returns if the final output format is bayer Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool has_alpha()Returns if the final output format has an alpha value Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. virtual void convert(const char &amp; src, char &amp; dest, const int &amp; bytes_used)Conversion method. Meant to be overridden if pixel format requires it. uint8_t channels()Number of channels (e.g. bytes) per pixel. uint8_t byte_depth()Number of bytes per channel. uint8_t bit_depth()Number for bit depth of image. <p>Protected Attributes inherited from usb_cam::formats::pixel_format_base</p> Name uint32_t m_v4l2 Integer correspoding to a specific V4L2_PIX_FMT_* constant See <code>linux/videodev2.h</code> for a list of all possible values for here. std::string m_ros This should match ROS encoding string See <code>sensor_msgs/image_encodings.hpp</code> for corresponding possible values. Copy of those values are stored in <code>[usb_cam/constants.hpp]</code> bool m_requires_conversion boolean whether or not the current format requires a call to <code>convert</code>. Setting this to true requires that the virtual <code>convert</code> method is implemented. std::string m_name Unique name for this pixel format. uint8_t m_channels Number of channels (aka bytes per pixel) of output (ROS format above) uint8_t m_bit_depth Bitdepth of output (ROS format above)"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1default__pixel__format/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1default__pixel__format/#function-default_pixel_format","title":"function default_pixel_format","text":"<pre><code>inline default_pixel_format()\n</code></pre> <p>Updated on 2024-01-20 at 18:16:12 +0000</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1pixel__format__base/","title":"usb_cam::formats::pixel_format_base","text":"<p>Base pixel format class. Provide all necessary information for converting between V4L2 and ROS formats. Meant to be overridden if conversion function is required. </p> <p><code>#include &lt;pixel_format_base.hpp&gt;</code></p> <p>Inherited by usb_cam::formats::M4202RGB, usb_cam::formats::MJPEG2RGB, usb_cam::formats::MONO16, usb_cam::formats::MONO8, usb_cam::formats::RAW_MJPEG, usb_cam::formats::RGB8, usb_cam::formats::UYVY, usb_cam::formats::UYVY2RGB, usb_cam::formats::Y102MONO8, usb_cam::formats::YUYV, usb_cam::formats::YUYV2RGB, usb_cam::formats::default_pixel_format</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1pixel__format__base/#public-functions","title":"Public Functions","text":"Name std::string v4l2_str()String value of V4L2 capture pixel format. uint32_t v4l2()Integer value of V4L2 capture pixel format. std::string ros()Name of output pixel (encoding) format to ROS. bool requires_conversion()True if the current pixel format requires a call to the <code>convert</code> method Used in the usb_cam library logic to determine if a plain <code>memcopy</code> call can be used instead of a call to the <code>convert</code> method of this class. pixel_format_base(std::string name, uint32_t v4l2, std::string ros, uint8_t channels, uint8_t bit_depth, bool requires_conversion) std::string name()Name of pixel format. Used in the parameters file to select this format. bool is_mono()Returns if the final output format is monocolor (gray) Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool is_color()Returns if the final output format is color Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool is_bayer()Returns if the final output format is bayer Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. bool has_alpha()Returns if the final output format has an alpha value Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. virtual void convert(const char &amp; src, char &amp; dest, const int &amp; bytes_used)Conversion method. Meant to be overridden if pixel format requires it. uint8_t channels()Number of channels (e.g. bytes) per pixel. uint8_t byte_depth()Number of bytes per channel. uint8_t bit_depth()Number for bit depth of image."},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1pixel__format__base/#protected-attributes","title":"Protected Attributes","text":"Name uint32_t m_v4l2 Integer correspoding to a specific V4L2_PIX_FMT_* constant See <code>linux/videodev2.h</code> for a list of all possible values for here. std::string m_ros This should match ROS encoding string See <code>sensor_msgs/image_encodings.hpp</code> for corresponding possible values. Copy of those values are stored in <code>[usb_cam/constants.hpp]</code> bool m_requires_conversion boolean whether or not the current format requires a call to <code>convert</code>. Setting this to true requires that the virtual <code>convert</code> method is implemented. std::string m_name Unique name for this pixel format. uint8_t m_channels Number of channels (aka bytes per pixel) of output (ROS format above) uint8_t m_bit_depth Bitdepth of output (ROS format above)"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1pixel__format__base/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1pixel__format__base/#function-v4l2_str","title":"function v4l2_str","text":"<pre><code>inline std::string v4l2_str()\n</code></pre> <p>String value of V4L2 capture pixel format. </p> <p>Return: std::string V4L2 capture pixel format </p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1pixel__format__base/#function-v4l2","title":"function v4l2","text":"<pre><code>inline uint32_t v4l2()\n</code></pre> <p>Integer value of V4L2 capture pixel format. </p> <p>Return: uint32_t V4L2 capture pixel format </p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1pixel__format__base/#function-ros","title":"function ros","text":"<pre><code>inline std::string ros()\n</code></pre> <p>Name of output pixel (encoding) format to ROS. </p> <p>Return: </p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1pixel__format__base/#function-requires_conversion","title":"function requires_conversion","text":"<pre><code>inline bool requires_conversion()\n</code></pre> <p>True if the current pixel format requires a call to the <code>convert</code> method Used in the usb_cam library logic to determine if a plain <code>memcopy</code> call can be used instead of a call to the <code>convert</code> method of this class. </p> <p>Return: </p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1pixel__format__base/#function-pixel_format_base","title":"function pixel_format_base","text":"<pre><code>inline pixel_format_base(\n    std::string name,\n    uint32_t v4l2,\n    std::string ros,\n    uint8_t channels,\n    uint8_t bit_depth,\n    bool requires_conversion\n)\n</code></pre>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1pixel__format__base/#function-name","title":"function name","text":"<pre><code>inline std::string name()\n</code></pre> <p>Name of pixel format. Used in the parameters file to select this format. </p> <p>Return: </p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1pixel__format__base/#function-is_mono","title":"function is_mono","text":"<pre><code>inline bool is_mono()\n</code></pre> <p>Returns if the final output format is monocolor (gray) Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. </p> <p>Return: </p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1pixel__format__base/#function-is_color","title":"function is_color","text":"<pre><code>inline bool is_color()\n</code></pre> <p>Returns if the final output format is color Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. </p> <p>Return: </p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1pixel__format__base/#function-is_bayer","title":"function is_bayer","text":"<pre><code>inline bool is_bayer()\n</code></pre> <p>Returns if the final output format is bayer Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. </p> <p>Return: </p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1pixel__format__base/#function-has_alpha","title":"function has_alpha","text":"<pre><code>inline bool has_alpha()\n</code></pre> <p>Returns if the final output format has an alpha value Copied from: https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp. </p> <p>Return: </p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1pixel__format__base/#function-convert","title":"function convert","text":"<pre><code>inline virtual void convert(\n    const char *&amp; src,\n    char *&amp; dest,\n    const int &amp; bytes_used\n)\n</code></pre> <p>Conversion method. Meant to be overridden if pixel format requires it. </p> <p>Reimplemented by: usb_cam::formats::M4202RGB::convert, usb_cam::formats::MJPEG2RGB::convert, usb_cam::formats::Y102MONO8::convert, usb_cam::formats::UYVY2RGB::convert, usb_cam::formats::YUYV2RGB::convert</p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1pixel__format__base/#function-channels","title":"function channels","text":"<pre><code>inline uint8_t channels()\n</code></pre> <p>Number of channels (e.g. bytes) per pixel. </p> <p>Return: </p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1pixel__format__base/#function-byte_depth","title":"function byte_depth","text":"<pre><code>inline uint8_t byte_depth()\n</code></pre> <p>Number of bytes per channel. </p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1pixel__format__base/#function-bit_depth","title":"function bit_depth","text":"<pre><code>inline uint8_t bit_depth()\n</code></pre> <p>Number for bit depth of image. </p> <p>Return: </p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1pixel__format__base/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1pixel__format__base/#variable-m_v4l2","title":"variable m_v4l2","text":"<pre><code>uint32_t m_v4l2;\n</code></pre> <p>Integer correspoding to a specific V4L2_PIX_FMT_* constant See <code>linux/videodev2.h</code> for a list of all possible values for here. </p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1pixel__format__base/#variable-m_ros","title":"variable m_ros","text":"<pre><code>std::string m_ros;\n</code></pre> <p>This should match ROS encoding string See <code>sensor_msgs/image_encodings.hpp</code> for corresponding possible values. Copy of those values are stored in <code>[usb_cam/constants.hpp]</code></p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1pixel__format__base/#variable-m_requires_conversion","title":"variable m_requires_conversion","text":"<pre><code>bool m_requires_conversion;\n</code></pre> <p>boolean whether or not the current format requires a call to <code>convert</code>. Setting this to true requires that the virtual <code>convert</code> method is implemented. </p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1pixel__format__base/#variable-m_name","title":"variable m_name","text":"<pre><code>std::string m_name;\n</code></pre> <p>Unique name for this pixel format. </p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1pixel__format__base/#variable-m_channels","title":"variable m_channels","text":"<pre><code>uint8_t m_channels;\n</code></pre> <p>Number of channels (aka bytes per pixel) of output (ROS format above) </p>"},{"location":"api-reference/Classes/classusb__cam_1_1formats_1_1pixel__format__base/#variable-m_bit_depth","title":"variable m_bit_depth","text":"<pre><code>uint8_t m_bit_depth;\n</code></pre> <p>Bitdepth of output (ROS format above) </p> <p>Updated on 2024-01-20 at 18:16:12 +0000</p>"},{"location":"api-reference/Classes/structusb__cam_1_1capture__format__t/","title":"usb_cam::capture_format_t","text":""},{"location":"api-reference/Classes/structusb__cam_1_1capture__format__t/#public-attributes","title":"Public Attributes","text":"Name struct v4l2_frmivalenum v4l2_fmt struct v4l2_fmtdesc format"},{"location":"api-reference/Classes/structusb__cam_1_1capture__format__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api-reference/Classes/structusb__cam_1_1capture__format__t/#variable-v4l2_fmt","title":"variable v4l2_fmt","text":"<pre><code>struct v4l2_frmivalenum v4l2_fmt;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1capture__format__t/#variable-format","title":"variable format","text":"<pre><code>struct v4l2_fmtdesc format;\n</code></pre> <p>Updated on 2024-01-20 at 18:16:12 +0000</p>"},{"location":"api-reference/Classes/structusb__cam_1_1formats_1_1format__arguments__t/","title":"usb_cam::formats::format_arguments_t","text":"<p>Helper structure to standardize all pixel_format_base constructors, so that they all have the same argument type.  More...</p> <p><code>#include &lt;pixel_format_base.hpp&gt;</code></p>"},{"location":"api-reference/Classes/structusb__cam_1_1formats_1_1format__arguments__t/#public-attributes","title":"Public Attributes","text":"Name int width size_t pixels std::string name int height std::string av_device_format_str"},{"location":"api-reference/Classes/structusb__cam_1_1formats_1_1format__arguments__t/#detailed-description","title":"Detailed Description","text":"<pre><code>struct usb_cam::formats::format_arguments_t;\n</code></pre> <p>Helper structure to standardize all pixel_format_base constructors, so that they all have the same argument type. </p> <p>This should also be easily extendable in the future if we need to add additional arguments for future pixel format(s) that are added. </p>"},{"location":"api-reference/Classes/structusb__cam_1_1formats_1_1format__arguments__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api-reference/Classes/structusb__cam_1_1formats_1_1format__arguments__t/#variable-width","title":"variable width","text":"<pre><code>int width = 640;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1formats_1_1format__arguments__t/#variable-pixels","title":"variable pixels","text":"<pre><code>size_t pixels = 640 * 480;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1formats_1_1format__arguments__t/#variable-name","title":"variable name","text":"<pre><code>std::string name = \"\";\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1formats_1_1format__arguments__t/#variable-height","title":"variable height","text":"<pre><code>int height = 480;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1formats_1_1format__arguments__t/#variable-av_device_format_str","title":"variable av_device_format_str","text":"<pre><code>std::string av_device_format_str = \"AV_PIX_FMT_YUV422P\";\n</code></pre> <p>Updated on 2024-01-20 at 18:16:12 +0000</p>"},{"location":"api-reference/Classes/structusb__cam_1_1image__t/","title":"usb_cam::image_t","text":""},{"location":"api-reference/Classes/structusb__cam_1_1image__t/#public-functions","title":"Public Functions","text":"Name size_t set_size_in_bytes() size_t set_number_of_pixels() size_t set_bytes_per_line() unsigned int get_format_fourcc()make it a shorter API call to get the pixel format"},{"location":"api-reference/Classes/structusb__cam_1_1image__t/#public-attributes","title":"Public Attributes","text":"Name size_t width v4l2_format v4l2_fmt struct timespec stamp size_t size_in_bytes std::shared_ptr&lt; pixel_format_base &gt; pixel_format size_t number_of_pixels size_t height char * data size_t bytes_per_line"},{"location":"api-reference/Classes/structusb__cam_1_1image__t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api-reference/Classes/structusb__cam_1_1image__t/#function-set_size_in_bytes","title":"function set_size_in_bytes","text":"<pre><code>inline size_t set_size_in_bytes()\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1image__t/#function-set_number_of_pixels","title":"function set_number_of_pixels","text":"<pre><code>inline size_t set_number_of_pixels()\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1image__t/#function-set_bytes_per_line","title":"function set_bytes_per_line","text":"<pre><code>inline size_t set_bytes_per_line()\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1image__t/#function-get_format_fourcc","title":"function get_format_fourcc","text":"<pre><code>inline unsigned int get_format_fourcc()\n</code></pre> <p>make it a shorter API call to get the pixel format </p>"},{"location":"api-reference/Classes/structusb__cam_1_1image__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api-reference/Classes/structusb__cam_1_1image__t/#variable-width","title":"variable width","text":"<pre><code>size_t width;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1image__t/#variable-v4l2_fmt","title":"variable v4l2_fmt","text":"<pre><code>v4l2_format v4l2_fmt;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1image__t/#variable-stamp","title":"variable stamp","text":"<pre><code>struct timespec stamp;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1image__t/#variable-size_in_bytes","title":"variable size_in_bytes","text":"<pre><code>size_t size_in_bytes;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1image__t/#variable-pixel_format","title":"variable pixel_format","text":"<pre><code>std::shared_ptr&lt; pixel_format_base &gt; pixel_format;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1image__t/#variable-number_of_pixels","title":"variable number_of_pixels","text":"<pre><code>size_t number_of_pixels;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1image__t/#variable-height","title":"variable height","text":"<pre><code>size_t height;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1image__t/#variable-data","title":"variable data","text":"<pre><code>char * data;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1image__t/#variable-bytes_per_line","title":"variable bytes_per_line","text":"<pre><code>size_t bytes_per_line;\n</code></pre> <p>Updated on 2024-01-20 at 18:16:12 +0000</p>"},{"location":"api-reference/Classes/structusb__cam_1_1parameters__t/","title":"usb_cam::parameters_t","text":""},{"location":"api-reference/Classes/structusb__cam_1_1parameters__t/#public-attributes","title":"Public Attributes","text":"Name int white_balance int sharpness int saturation std::string pixel_format_name std::string io_method_name int image_width int image_height int gain int framerate std::string frame_id int focus int exposure std::string device_name int contrast std::string camera_name std::string camera_info_url int brightness std::string av_device_format bool autofocus bool autoexposure bool auto_white_balance"},{"location":"api-reference/Classes/structusb__cam_1_1parameters__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api-reference/Classes/structusb__cam_1_1parameters__t/#variable-white_balance","title":"variable white_balance","text":"<pre><code>int white_balance;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1parameters__t/#variable-sharpness","title":"variable sharpness","text":"<pre><code>int sharpness;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1parameters__t/#variable-saturation","title":"variable saturation","text":"<pre><code>int saturation;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1parameters__t/#variable-pixel_format_name","title":"variable pixel_format_name","text":"<pre><code>std::string pixel_format_name;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1parameters__t/#variable-io_method_name","title":"variable io_method_name","text":"<pre><code>std::string io_method_name;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1parameters__t/#variable-image_width","title":"variable image_width","text":"<pre><code>int image_width;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1parameters__t/#variable-image_height","title":"variable image_height","text":"<pre><code>int image_height;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1parameters__t/#variable-gain","title":"variable gain","text":"<pre><code>int gain;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1parameters__t/#variable-framerate","title":"variable framerate","text":"<pre><code>int framerate;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1parameters__t/#variable-frame_id","title":"variable frame_id","text":"<pre><code>std::string frame_id;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1parameters__t/#variable-focus","title":"variable focus","text":"<pre><code>int focus;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1parameters__t/#variable-exposure","title":"variable exposure","text":"<pre><code>int exposure;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1parameters__t/#variable-device_name","title":"variable device_name","text":"<pre><code>std::string device_name;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1parameters__t/#variable-contrast","title":"variable contrast","text":"<pre><code>int contrast;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1parameters__t/#variable-camera_name","title":"variable camera_name","text":"<pre><code>std::string camera_name;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1parameters__t/#variable-camera_info_url","title":"variable camera_info_url","text":"<pre><code>std::string camera_info_url;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1parameters__t/#variable-brightness","title":"variable brightness","text":"<pre><code>int brightness;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1parameters__t/#variable-av_device_format","title":"variable av_device_format","text":"<pre><code>std::string av_device_format;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1parameters__t/#variable-autofocus","title":"variable autofocus","text":"<pre><code>bool autofocus;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1parameters__t/#variable-autoexposure","title":"variable autoexposure","text":"<pre><code>bool autoexposure;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1parameters__t/#variable-auto_white_balance","title":"variable auto_white_balance","text":"<pre><code>bool auto_white_balance;\n</code></pre> <p>Updated on 2024-01-20 at 18:16:12 +0000</p>"},{"location":"api-reference/Classes/structusb__cam_1_1utils_1_1buffer/","title":"usb_cam::utils::buffer","text":""},{"location":"api-reference/Classes/structusb__cam_1_1utils_1_1buffer/#public-attributes","title":"Public Attributes","text":"Name char * start size_t length"},{"location":"api-reference/Classes/structusb__cam_1_1utils_1_1buffer/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api-reference/Classes/structusb__cam_1_1utils_1_1buffer/#variable-start","title":"variable start","text":"<pre><code>char * start;\n</code></pre>"},{"location":"api-reference/Classes/structusb__cam_1_1utils_1_1buffer/#variable-length","title":"variable length","text":"<pre><code>size_t length;\n</code></pre> <p>Updated on 2024-01-20 at 18:16:12 +0000</p>"},{"location":"api-reference/Modules/","title":"Modules","text":"<p>Updated on 2024-01-20 at 18:16:12 +0000</p>"},{"location":"api-reference/Namespaces/","title":"Namespaces","text":"<ul> <li>namespace rclcpp </li> <li>namespace usb_cam <ul> <li>namespace constants </li> <li>namespace conversions </li> <li>namespace formats </li> <li>namespace utils </li> </ul> </li> </ul> <p>Updated on 2024-01-20 at 18:16:12 +0000</p>"},{"location":"api-reference/Namespaces/namespacerclcpp/","title":"rclcpp","text":"<p>Updated on 2024-01-20 at 18:16:12 +0000</p>"},{"location":"api-reference/Namespaces/namespaceusb__cam/","title":"usb_cam","text":""},{"location":"api-reference/Namespaces/namespaceusb__cam/#namespaces","title":"Namespaces","text":"Name usb_cam::utils usb_cam::formats usb_cam::conversions usb_cam::constants"},{"location":"api-reference/Namespaces/namespaceusb__cam/#classes","title":"Classes","text":"Name struct usb_cam::parameters_t struct usb_cam::image_t struct usb_cam::capture_format_t class usb_cam::UsbCamNode class usb_cam::UsbCam"},{"location":"api-reference/Namespaces/namespaceusb__cam/#functions","title":"Functions","text":"Name std::vector&lt; std::shared_ptr&lt; pixel_format_base &gt; &gt; driver_supported_formats(const formats::format_arguments_t &amp; args =formats::format_arguments_t())list all supported formats that this driver supports"},{"location":"api-reference/Namespaces/namespaceusb__cam/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api-reference/Namespaces/namespaceusb__cam/#function-driver_supported_formats","title":"function driver_supported_formats","text":"<pre><code>std::vector&lt; std::shared_ptr&lt; pixel_format_base &gt; &gt; driver_supported_formats(\n    const formats::format_arguments_t &amp; args =formats::format_arguments_t()\n)\n</code></pre> <p>list all supported formats that this driver supports </p> <p>Updated on 2024-01-20 at 18:16:12 +0000</p>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/","title":"usb_cam::constants","text":""},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#attributes","title":"Attributes","text":"Name const std::vector&lt; unsigned char &gt; uchar_clipping_table const int clipping_table_offset const char YUV422_YUY2 const char YUV422 const char UNKNOWN const char TYPE_8UC4 const char TYPE_8UC3 const char TYPE_8UC2 const char TYPE_8UC1 const char TYPE_8SC4 const char TYPE_8SC3 const char TYPE_8SC2 const char TYPE_8SC1 const char TYPE_64FC4 const char TYPE_64FC3 const char TYPE_64FC2 const char TYPE_64FC1 const char TYPE_32SC4 const char TYPE_32SC3 const char TYPE_32SC2 const char TYPE_32SC1 const char TYPE_32FC4 const char TYPE_32FC3 const char TYPE_32FC2 const char TYPE_32FC1 const char TYPE_16UC4 const char TYPE_16UC3 const char TYPE_16UC2 const char TYPE_16UC1 const char TYPE_16SC4 const char TYPE_16SC3 const char TYPE_16SC2 const char TYPE_16SC1 const char RGBA8 const char RGBA16 const char RGB8 image encodings duplicated from https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp const char RGB16 const char NV24 const char NV21 const char MONO8 const char MONO16 const char BGRA8 const char BGRA16 const char BGR8 const char BGR16 const char BAYER_RGGB8 const char BAYER_RGGB16 const char BAYER_GRBG8 const char BAYER_GRBG16 const char BAYER_GBRG8 const char BAYER_GBRG16 const char BAYER_BGGR8 const char BAYER_BGGR16"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-uchar_clipping_table","title":"variable uchar_clipping_table","text":"<pre><code>const std::vector&lt; unsigned char &gt; uchar_clipping_table;\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-clipping_table_offset","title":"variable clipping_table_offset","text":"<pre><code>const int clipping_table_offset = 128;\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-yuv422_yuy2","title":"variable YUV422_YUY2","text":"<pre><code>const char YUV422_YUY2 = \"yuv422_yuy2\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-yuv422","title":"variable YUV422","text":"<pre><code>const char YUV422 = \"yuv422\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-unknown","title":"variable UNKNOWN","text":"<pre><code>const char UNKNOWN = \"unknown\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-type_8uc4","title":"variable TYPE_8UC4","text":"<pre><code>const char TYPE_8UC4 = \"8UC4\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-type_8uc3","title":"variable TYPE_8UC3","text":"<pre><code>const char TYPE_8UC3 = \"8UC3\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-type_8uc2","title":"variable TYPE_8UC2","text":"<pre><code>const char TYPE_8UC2 = \"8UC2\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-type_8uc1","title":"variable TYPE_8UC1","text":"<pre><code>const char TYPE_8UC1 = \"8UC1\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-type_8sc4","title":"variable TYPE_8SC4","text":"<pre><code>const char TYPE_8SC4 = \"8SC4\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-type_8sc3","title":"variable TYPE_8SC3","text":"<pre><code>const char TYPE_8SC3 = \"8SC3\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-type_8sc2","title":"variable TYPE_8SC2","text":"<pre><code>const char TYPE_8SC2 = \"8SC2\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-type_8sc1","title":"variable TYPE_8SC1","text":"<pre><code>const char TYPE_8SC1 = \"8SC1\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-type_64fc4","title":"variable TYPE_64FC4","text":"<pre><code>const char TYPE_64FC4 = \"64FC4\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-type_64fc3","title":"variable TYPE_64FC3","text":"<pre><code>const char TYPE_64FC3 = \"64FC3\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-type_64fc2","title":"variable TYPE_64FC2","text":"<pre><code>const char TYPE_64FC2 = \"64FC2\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-type_64fc1","title":"variable TYPE_64FC1","text":"<pre><code>const char TYPE_64FC1 = \"64FC1\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-type_32sc4","title":"variable TYPE_32SC4","text":"<pre><code>const char TYPE_32SC4 = \"32SC4\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-type_32sc3","title":"variable TYPE_32SC3","text":"<pre><code>const char TYPE_32SC3 = \"32SC3\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-type_32sc2","title":"variable TYPE_32SC2","text":"<pre><code>const char TYPE_32SC2 = \"32SC2\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-type_32sc1","title":"variable TYPE_32SC1","text":"<pre><code>const char TYPE_32SC1 = \"32SC1\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-type_32fc4","title":"variable TYPE_32FC4","text":"<pre><code>const char TYPE_32FC4 = \"32FC4\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-type_32fc3","title":"variable TYPE_32FC3","text":"<pre><code>const char TYPE_32FC3 = \"32FC3\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-type_32fc2","title":"variable TYPE_32FC2","text":"<pre><code>const char TYPE_32FC2 = \"32FC2\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-type_32fc1","title":"variable TYPE_32FC1","text":"<pre><code>const char TYPE_32FC1 = \"32FC1\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-type_16uc4","title":"variable TYPE_16UC4","text":"<pre><code>const char TYPE_16UC4 = \"16UC4\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-type_16uc3","title":"variable TYPE_16UC3","text":"<pre><code>const char TYPE_16UC3 = \"16UC3\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-type_16uc2","title":"variable TYPE_16UC2","text":"<pre><code>const char TYPE_16UC2 = \"16UC2\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-type_16uc1","title":"variable TYPE_16UC1","text":"<pre><code>const char TYPE_16UC1 = \"16UC1\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-type_16sc4","title":"variable TYPE_16SC4","text":"<pre><code>const char TYPE_16SC4 = \"16SC4\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-type_16sc3","title":"variable TYPE_16SC3","text":"<pre><code>const char TYPE_16SC3 = \"16SC3\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-type_16sc2","title":"variable TYPE_16SC2","text":"<pre><code>const char TYPE_16SC2 = \"16SC2\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-type_16sc1","title":"variable TYPE_16SC1","text":"<pre><code>const char TYPE_16SC1 = \"16SC1\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-rgba8","title":"variable RGBA8","text":"<pre><code>const char RGBA8 = \"rgba8\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-rgba16","title":"variable RGBA16","text":"<pre><code>const char RGBA16 = \"rgba16\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-rgb8","title":"variable RGB8","text":"<pre><code>const char RGB8 = \"rgb8\";\n</code></pre> <p>image encodings duplicated from https://github.com/ros2/common_interfaces/blob/rolling/sensor_msgs/include/sensor_msgs/image_encodings.hpp</p>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-rgb16","title":"variable RGB16","text":"<pre><code>const char RGB16 = \"rgb16\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-nv24","title":"variable NV24","text":"<pre><code>const char NV24 = \"nv24\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-nv21","title":"variable NV21","text":"<pre><code>const char NV21 = \"nv21\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-mono8","title":"variable MONO8","text":"<pre><code>const char MONO8 = \"mono8\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-mono16","title":"variable MONO16","text":"<pre><code>const char MONO16 = \"mono16\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-bgra8","title":"variable BGRA8","text":"<pre><code>const char BGRA8 = \"bgra8\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-bgra16","title":"variable BGRA16","text":"<pre><code>const char BGRA16 = \"bgra16\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-bgr8","title":"variable BGR8","text":"<pre><code>const char BGR8 = \"bgr8\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-bgr16","title":"variable BGR16","text":"<pre><code>const char BGR16 = \"bgr16\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-bayer_rggb8","title":"variable BAYER_RGGB8","text":"<pre><code>const char BAYER_RGGB8 = \"bayer_rggb8\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-bayer_rggb16","title":"variable BAYER_RGGB16","text":"<pre><code>const char BAYER_RGGB16 = \"bayer_rggb16\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-bayer_grbg8","title":"variable BAYER_GRBG8","text":"<pre><code>const char BAYER_GRBG8 = \"bayer_grbg8\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-bayer_grbg16","title":"variable BAYER_GRBG16","text":"<pre><code>const char BAYER_GRBG16 = \"bayer_grbg16\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-bayer_gbrg8","title":"variable BAYER_GBRG8","text":"<pre><code>const char BAYER_GBRG8 = \"bayer_gbrg8\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-bayer_gbrg16","title":"variable BAYER_GBRG16","text":"<pre><code>const char BAYER_GBRG16 = \"bayer_gbrg16\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-bayer_bggr8","title":"variable BAYER_BGGR8","text":"<pre><code>const char BAYER_BGGR8 = \"bayer_bggr8\";\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1constants/#variable-bayer_bggr16","title":"variable BAYER_BGGR16","text":"<pre><code>const char BAYER_BGGR16 = \"bayer_bggr16\";\n</code></pre> <p>Updated on 2024-01-20 at 18:16:12 +0000</p>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1conversions/","title":"usb_cam::conversions","text":""},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1conversions/#functions","title":"Functions","text":"Name std::string FCC2S(const unsigned int &amp; val)"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1conversions/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1conversions/#function-fcc2s","title":"function FCC2S","text":"<pre><code>std::string FCC2S(\n    const unsigned int &amp; val\n)\n</code></pre> <p>Updated on 2024-01-20 at 18:16:12 +0000</p>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1formats/","title":"usb_cam::formats","text":""},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1formats/#classes","title":"Classes","text":"Name class usb_cam::formats::pixel_format_base Base pixel format class. Provide all necessary information for converting between V4L2 and ROS formats. Meant to be overridden if conversion function is required. struct usb_cam::formats::format_arguments_t Helper structure to standardize all pixel_format_base constructors, so that they all have the same argument type. class usb_cam::formats::default_pixel_format class usb_cam::formats::YUYV2RGB class usb_cam::formats::YUYV class usb_cam::formats::Y102MONO8 Also known as MONO10 to MONO8. class usb_cam::formats::UYVY2RGB class usb_cam::formats::UYVY class usb_cam::formats::RGB8 class usb_cam::formats::RAW_MJPEG class usb_cam::formats::MONO8 class usb_cam::formats::MONO16 class usb_cam::formats::MJPEG2RGB class usb_cam::formats::M4202RGB"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1formats/#functions","title":"Functions","text":"Name std::string get_ros_pixel_format_from_av_format(const AVPixelFormat &amp; avPixelFormat)Get ROS PixelFormat from AVPixelFormat. std::string get_ros_pixel_format_from_av_format(const std::string avPixelFormatStr)Overload to support av pixel formats being passed as strings. uint8_t get_channels_from_av_format(const AVPixelFormat &amp; avPixelFormat)Get the number of channels from AVPixelFormat. uint8_t get_channels_from_av_format(const std::string &amp; avPixelFormatStr)Overload of function below to support av pixel formats as strings. uint8_t get_bit_depth_from_av_format(const AVPixelFormat &amp; avPixelFormat)Get the pixel bit depth from AVPixelFormat. uint8_t get_bit_depth_from_av_format(const std::string &amp; avPixelFormatStr)Overload of function below to support passing av pixel formats as strings. AVPixelFormat get_av_pixel_format_from_string(const std::string &amp; str)Get AVPixelFormat from string. This string should correspond to the AVPixelFormat name. The name can either be given with or without the 'AV_PIX_FMT_' prefix. void YUV2RGB(const unsigned char &amp; y, const unsigned char &amp; u, const unsigned char &amp; v, unsigned char * r, unsigned char * g, unsigned char * b)Conversion from YUV to RGB. unsigned char CLIPVALUE(const int &amp; val)"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1formats/#attributes","title":"Attributes","text":"Name const std::unordered_map&lt; std::string, AVPixelFormat &gt; STR_2_AVPIXFMT Map to associate string of pixel format name to actual pixel format enum."},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1formats/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1formats/#function-get_ros_pixel_format_from_av_format","title":"function get_ros_pixel_format_from_av_format","text":"<pre><code>inline std::string get_ros_pixel_format_from_av_format(\n    const AVPixelFormat &amp; avPixelFormat\n)\n</code></pre> <p>Get ROS PixelFormat from AVPixelFormat. </p> <p>Parameters: </p> <ul> <li>avPixelFormat AVPixelFormat </li> </ul> <p>Return: String specifying the ROS pixel format. </p>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1formats/#function-get_ros_pixel_format_from_av_format_1","title":"function get_ros_pixel_format_from_av_format","text":"<pre><code>inline std::string get_ros_pixel_format_from_av_format(\n    const std::string avPixelFormatStr\n)\n</code></pre> <p>Overload to support av pixel formats being passed as strings. </p> <p>Parameters: </p> <ul> <li>avPixelFormat AvPixelFormat as string </li> </ul> <p>Return: String specifying the ROS pixel format. </p>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1formats/#function-get_channels_from_av_format","title":"function get_channels_from_av_format","text":"<pre><code>inline uint8_t get_channels_from_av_format(\n    const AVPixelFormat &amp; avPixelFormat\n)\n</code></pre> <p>Get the number of channels from AVPixelFormat. </p> <p>Parameters: </p> <ul> <li>avPixelFormat AVPixelFormat </li> </ul> <p>Return: Number of channels as uint8 </p>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1formats/#function-get_channels_from_av_format_1","title":"function get_channels_from_av_format","text":"<pre><code>inline uint8_t get_channels_from_av_format(\n    const std::string &amp; avPixelFormatStr\n)\n</code></pre> <p>Overload of function below to support av pixel formats as strings. </p> <p>Parameters: </p> <ul> <li>avPixelFormatStr AvPixelFormat as string </li> </ul> <p>Return: Number of channels as uint8_t </p>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1formats/#function-get_bit_depth_from_av_format","title":"function get_bit_depth_from_av_format","text":"<pre><code>inline uint8_t get_bit_depth_from_av_format(\n    const AVPixelFormat &amp; avPixelFormat\n)\n</code></pre> <p>Get the pixel bit depth from AVPixelFormat. </p> <p>Parameters: </p> <ul> <li>avPixelFormat AVPixelFormat </li> </ul> <p>Return: Bit depth as uint8 </p>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1formats/#function-get_bit_depth_from_av_format_1","title":"function get_bit_depth_from_av_format","text":"<pre><code>inline uint8_t get_bit_depth_from_av_format(\n    const std::string &amp; avPixelFormatStr\n)\n</code></pre> <p>Overload of function below to support passing av pixel formats as strings. </p> <p>Parameters: </p> <ul> <li>avPixelFormatStr AVPixelFormat as string </li> </ul> <p>Return: Bit depth as uint8 </p>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1formats/#function-get_av_pixel_format_from_string","title":"function get_av_pixel_format_from_string","text":"<pre><code>inline AVPixelFormat get_av_pixel_format_from_string(\n    const std::string &amp; str\n)\n</code></pre> <p>Get AVPixelFormat from string. This string should correspond to the AVPixelFormat name. The name can either be given with or without the 'AV_PIX_FMT_' prefix. </p> <p>Parameters: </p> <ul> <li>str AVPixelFormat name </li> </ul> <p>Return: Pixel format enum corresponding to a given name </p>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1formats/#function-yuv2rgb","title":"function YUV2RGB","text":"<pre><code>inline void YUV2RGB(\n    const unsigned char &amp; y,\n    const unsigned char &amp; u,\n    const unsigned char &amp; v,\n    unsigned char * r,\n    unsigned char * g,\n    unsigned char * b\n)\n</code></pre> <p>Conversion from YUV to RGB. </p> <p>The normal conversion matrix is due to Julien (surname unknown):</p> <p>[ R ] [ 1.0 0.0 1.403 ] [ Y ] [ G ] = [ 1.0 -0.344 -0.714 ] [ U ] [ B ] [ 1.0 1.770 0.0 ] [ V ]</p> <p>and the firewire one is similar:</p> <p>[ R ] [ 1.0 0.0 0.700 ] [ Y ] [ G ] = [ 1.0 -0.198 -0.291 ] [ U ] [ B ] [ 1.0 1.015 0.0 ] [ V ]</p> <p>Corrected by BJT (coriander's transforms RGB-&gt;YUV and YUV-&gt;RGB do not get you back to the same RGB!) [ R ] [ 1.0 0.0 1.136 ] [ Y ] [ G ] = [ 1.0 -0.396 -0.578 ] [ U ] [ B ] [ 1.0 2.041 0.002 ] [ V ] </p>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1formats/#function-clipvalue","title":"function CLIPVALUE","text":"<pre><code>inline unsigned char CLIPVALUE(\n    const int &amp; val\n)\n</code></pre> <p>Clip a value to the range 0&lt;val&lt;255. For speed this is done using an array, so can only cope with numbers in the range -128&lt;=val&lt;=383. </p>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1formats/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1formats/#variable-str_2_avpixfmt","title":"variable STR_2_AVPIXFMT","text":"<pre><code>const std::unordered_map&lt; std::string, AVPixelFormat &gt; STR_2_AVPIXFMT;\n</code></pre> <p>Map to associate string of pixel format name to actual pixel format enum. </p> <p>Updated on 2024-01-20 at 18:16:12 +0000</p>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1utils/","title":"usb_cam::utils","text":""},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1utils/#classes","title":"Classes","text":"Name struct usb_cam::utils::buffer"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1utils/#types","title":"Types","text":"Name enum io_method_t { IO_METHOD_USERPTR, IO_METHOD_UNKNOWN, IO_METHOD_READ, IO_METHOD_MMAP}Read more on IO methods here: https://lwn.net/Articles/240667/."},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1utils/#functions","title":"Functions","text":"Name int xioctl(int fd, uint64_t request, void * arg) io_method_t io_method_from_string(const std::string &amp; str) time_t get_epoch_time_shift_us()Get epoch time shift in microseconds. timespec calc_img_timestamp(const timeval &amp; buffer_time, const time_t &amp; epoch_time_shift_us)Calculate image timestamp from buffer time and epoch time shift. In this, the buffer time is first converted into microseconds before the epoch time shift, which is to be given in microseconds is added to it. Afterwards it is split into seconds and nanoseconds for the image timestamp. std::map&lt; std::string, v4l2_capability &gt; available_devices()List currently available valid V4L2 devices Can be used to check if a device string is valid before starting up."},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1utils/#types-documentation","title":"Types Documentation","text":""},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1utils/#enum-io_method_t","title":"enum io_method_t","text":"Enumerator Value Description IO_METHOD_USERPTR memory buffers allocated in the user space IO_METHOD_UNKNOWN IO_METHOD_READ read method copies the video frame between user and kernal space IO_METHOD_MMAP memory mapped buffers allocated in kernel space <p>Read more on IO methods here: https://lwn.net/Articles/240667/. </p>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1utils/#functions-documentation","title":"Functions Documentation","text":""},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1utils/#function-xioctl","title":"function xioctl","text":"<pre><code>inline int xioctl(\n    int fd,\n    uint64_t request,\n    void * arg\n)\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1utils/#function-io_method_from_string","title":"function io_method_from_string","text":"<pre><code>inline io_method_t io_method_from_string(\n    const std::string &amp; str\n)\n</code></pre>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1utils/#function-get_epoch_time_shift_us","title":"function get_epoch_time_shift_us","text":"<pre><code>inline time_t get_epoch_time_shift_us()\n</code></pre> <p>Get epoch time shift in microseconds. </p> <p>Run this at start of process to calculate epoch time shift https://stackoverflow.com/questions/10266451/where-does-v4l2-buffer-timestamp-value-starts-counting</p>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1utils/#function-calc_img_timestamp","title":"function calc_img_timestamp","text":"<pre><code>inline timespec calc_img_timestamp(\n    const timeval &amp; buffer_time,\n    const time_t &amp; epoch_time_shift_us\n)\n</code></pre> <p>Calculate image timestamp from buffer time and epoch time shift. In this, the buffer time is first converted into microseconds before the epoch time shift, which is to be given in microseconds is added to it. Afterwards it is split into seconds and nanoseconds for the image timestamp. </p>"},{"location":"api-reference/Namespaces/namespaceusb__cam_1_1utils/#function-available_devices","title":"function available_devices","text":"<pre><code>inline std::map&lt; std::string, v4l2_capability &gt; available_devices()\n</code></pre> <p>List currently available valid V4L2 devices Can be used to check if a device string is valid before starting up. </p> <p>Inspired by: http://stackoverflow.com/questions/4290834/how-to-get-a-list-of-video-capture-devices-web-cameras-on-linux-ubuntu-c</p> <p>Updated on 2024-01-20 at 18:16:12 +0000</p>"}]}